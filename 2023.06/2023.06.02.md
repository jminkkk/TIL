# MySQL을 학습해야 하는 이유
관계형  DB 가장 범용적으로 사용

## MySQL

가장 많이 사용되는 관계형 DB

높은 접근성과 낮은 비용

SQL 안식 표준을 지키고 있음

## 쿼리 파서

SQL을 파싱하여 Syntax Tree를 만듬

이 과정에서 문법 오류 검사가 이루어짐

## 전처리기

쿼리파서에서 만든 Tree를 바탕으로 전처리 시작!!

테이블이나 컬럼 존재 여부, 접근권한 등 Semantic 오류 검사

→ 쿼리 파서와 전처리기 컴파일 과정과 매우 유사하지만 SQL은 프로그래밍 언어처럼 컴파일 타임 때 검증할 수 없음

## 옵티마이저

쿼리를 처리하기 위한 여러 방법을 만들고 각 방법들의 비용정보와 테이블의 통계 정보를 이용해 비용을 산정

- 테이블 순서, 불필요한 조건 제거, 통계 정보를 바탕으로 전략 결정
    - 실행 계획 수립
- 옵티마이저가 어떤 전략을 결정하냐에 따라 성능이 많이 차이남
    - 항상 좋은 판단을 하는 것이 아님

## 쿼리실행기


옵티마이저가 전략을 결정하면 쿼리실행기가 해당 전략대로 스토리지 엔진을 요청(Handler 요청이라 함)

## 쿼리캐시?

- MySQL에는 소프트파싱 X
    - 5버전까지는 쿼리 캐시가 존재 → SQL에 해당하는 데이터를 저장하는 것
    
    → 쿼리 캐시는 데이터를 캐시하기 때문에 테이블의 데이터가 변경되면 캐시의 데이터도 함께 갱신해줘야 함
    
- Oracle에는 소프트파싱 존재
    - 실행계획까지만 캐싱

MySQL의 쿼리캐시(조회에서 우수) & Oracle의 소프트 파싱(쓰기에서 우수)

→ 모두 성능 최적화를 위해 캐시라는 기술을 도입한 사례

But, 캐시의 범위가 다르므로 캐시를 도입할 때는 만료기간을 확인해야 함

---

소프트 파싱 : SQL, 실행계획을 캐시에서 찾아 옵티마이저 과정을 생략하고 실행 단계로 넘어감

하드 파싱 : SQL, 실행계획을 캐시에서 찾지 못해 옵티마이저 과정을 거치고나서 실행단계로 넘어감

## 스토리지 엔진

디스크에서 데이터를 가져오거나 저장하는 역할

MySQL 스토리지 엔진은 플러그인 형태로, Handler API만 맞춘다면 직접 구현해 사용 가능

MySQL → InnoDB 스토리지