# Dynamic Programming(동적 계획법)

> 다음의  글을 보고 정리한 내용입니다.
> 
> [알고리즘 - Dynamic Programming(동적 계획법)](https://hongjw1938.tistory.com/47)
> 
>  [[자료구조와 알고리즘] 동적 계획법(Dynamic Programming, DP)](https://velog.io/@chelsea/1-동적-계획법Dynamic-Programming-DP)
## 동적 계획법이란?

- 하나의 큰 문제를 여러 개의 작은 문제로 **나누어서 그 결과를 저장**하여 다시 큰 문제를 해결할 때 사용하는 것
    - 즉, 답을 저장해두고 **재활용**하는 것
- 특정한 알고리즘이   아닌 하나의 문제해결 패러다임

## 사용이유?

- 일반적인 재귀를 단순히 사용 시
    - 동일한 작은 문제들이 여러 번 반복 되어 비효율적인 계산될 가능성이 있음

## DP의 조건 2가지

1. 겹치는 부분 문제
    1. **동일한 작은 문제들이 반복하여 나타나는 경우에 사용이 가능**
2. 최적 부분 구조
    1. **부분 문제의 최적 결과 값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우**

## DP 과정

1. DP로 풀 수 있는 문제인지 확인
    - 조건들이 충족되는 문제인지를 한 번 체크
2. 문제의 변수 파악
    - 현재 변수에 따라 그 결과 값을 찾고 그것을 전달하여 재사용하는 것
    - **즉, 문제 내 변수의 개수를 알아내야 한다는 것**
        - 영어로 "state"를 결정한다고 함
3. 변수 간 관계식 만들기(점화식)
    - **점화식을** 통해 우리면 짧은 코드 내에서 반복/재귀를 통해 문제가 자동으로 해결되도록 구축
4. 메모하기(memoization or tabulation)
    - 변수 간 관계식까지 정상적으로 생성되었다면 **변수의 값에 따른 결과를 저장**
    해야 함
    - 보통 **배열을 사용하**여 저장하며 배열의 차원은 1-3차원까지 다양
5. 기저 상태 파악하기
    - 가장 작은 문제의 상태를 알아야함
        - 기저 문제에 대해 파악 후, 미리 배열에 저장해두기
6. 구현하기

## 구현 방법

### 1. Bottom-up

**아래에서부터 계산을 수행하고 누적시켜서 전체 큰 문제를 해결하는 방식**

```java
int fibo(int n) {
  fibodata[0] = 0;
  fiboData[1] = 1;
  for (int i=2; i<=n; i++)
    fiboData[i] = fiboData[i - 1] + fiboData[i - 2];
  return fiboData[n];
}
```

### 2. Top-Down

dp[n]의 값을 찾기 위해 **위에서부터 바로 호출을 시작하여** dp[0]의 상태까지 내려간 다음 해당 결과 값을 재귀를 통해 전이시켜 재활용하는 방식
