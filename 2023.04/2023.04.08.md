# 자바 모듈 시스템
> 모던 자바 인 액션 14장을 보고 정리한 내용입니다.
소프트웨어 아키텍처, 즉 고수준에서는 기반 코드를 바꿔야 할 때 유추하기 쉬우므로 생산성을 높일 수 있는 소프트웨어 프로젝트가 필요

추론하기 쉬운 소프트웨어를 만드는데 도움을 주는 관심사 분리와 정보 은닉

## 관심사 분리(SoC)

관심사 분리는 컴퓨터 프로그램을 **고유의 기능으로 나누는 동작을 권장하는 원칙**

- 다양한 형식으로 구성된 지출을 파싱하고
- 분석한 다음 결과를 고객에게 요약 보고하는 회계 어플리케이션 개발한다 가정

→ 관심사분리를 적용함으로서 파싱, 분석, 레포트 기능을 모듈이라는 각각의 부분 

즉, **서로 거의 겹치지 않는 코드 그룹으로 분리 가능**

### SoC의 장점

- 개별 기능을 따로 작업할 수 있으므로 팀이 쉽게 협업 가능
- 개별 부분을 재사용하기 쉬움
- 전체 시스템을 쉽게 유지보수 가능

## 정보 은닉

정보 은식은 **세부 구현을 숨기도록 장려하**는 원칙

- 세부 구현을 숨김으로 프로그램의 어떤 부분을 바꿨을 때 다른 부분까지 영향을 미칠 가능성을 줄일 수 있음
- 즉 코드를 관리하고 보호하는 데 유용한 원칙
    - 캡슐화된 코드의 내부적인 변화가 의도치 않게 외부에 영향을 미칠 가능성 감소

자바에서는 클래스 내의 컴포넌트에 적절하게 **private 키워드를 사용했는지**를 기준으로 컴파일러를 이용해 캡슐화 확인 가능 

## 모듈화의 한계

### 제한된 가시성 제어

- 자바는 정보를 감출 수 있는 **접근자** 제공
- public, protected, 패키지 수준, private의 4가지 가시성 접근자

**패키지 간의 가시성을 어떻게 제어?**

- 한 패키지의 클래스와 인터페이스를 다른 패키지로 공개하려면 public으로 선언해야 함
    - 이들 클래스와 인터페이스는 모두에게 공개
- 특히, “impl”이라는 문자열을 가진 패키지의 경우
    - 보통 패키지 내부의 접근자가 public이므로 사용자가 이 내부 구현을 마음대로 사용 가능
    - 내부적으로 사용할 목적으로 만든 구현을 다른 프로그래머가 임시적으로 사용해서 정착 가능
    - 기존의 애플리케이션을 망가뜨리지 않고 라이브러리 코드를 바꾸기 힘듬

### 클래스 경로

**애플리케이션을 번들하고 실행하는 기능**

- 클래스를 모두 컴파일한 다음
- 보통 한 개의 평범한 JAR파일에 넣고
- 클래스 경로에 이 JAR 파일을 추가해 사용 가능
- JVM이 동적으로 클래스 경로에 정의된 클래스를 필요할 때 읽음

**클래스 경로와 JAR 조합에 대한 자바의 약점**

1. 클래스 경로에는 같은 클래스를 구분하는 버전 개념이 없음
    - 파싱 라이브러리의 JSONParser 클래스를 지정할 때 버전 1.0? 2.0?을 지정할 수 없음
    - 클래스 경로에 두 가지 버전의 같은 라이브러리가 존재할 때 어떤 일이 일어날지 모름
2. 클래스 경로는 명시적인 의존성을 지원하지 X
    - 각각의 JAR 안에 있는 모든 클래스는 classes라는 한 주머니로 합쳐짐
    - 즉 한JAR가 다른 JAR에 포함된 클래스 집합을 사용하라고 명시적으로 의존성을 정의하는 기능을 제공X
        - 때문에 ‘빠진 것이 있는가?’와 ‘충돌이 있는가?’ 같은 의문이 들게 됨

### 거대한 JDK

JDK는 자바 프로그램을 만들고 실행하는 데 도움을 주는 도구의 집합

→ JDK가 발전하면서 많은 기술이 추가되었다 사장되기를 반복

- JDK에서 필요한 부분만 골라 사용하고 클래스 경로를 쉽게 유추할 수 있으며,
- 플랫폼을 진화시킬 수 있는 강력한 캡슐화를 제공할 새로운 건축 구조가 필요해짐