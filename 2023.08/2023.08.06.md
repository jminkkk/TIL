# JPA, JPQL
데이터베이스는 기본 키의 값으로 각 로우를 구분

반면에 객체는 동일성(identity) 비교와 동등성(equality) 비교라는 2가지 방법이 존재
+ 동일성 비교는 ==비교로 객체 인스턴스의 주소 값을 비교함
+ 동등성 비교는 equals() 메서드를 사용해 객체 내부의 값을 비교함

따라서 테이블의 로우를 구분하는 방법과 객체를 구분하는 방법에는 차이가 있음

```java
String memberId = "0719";
Member jminkkk = memberDAO.getMember(memberId);
Member jimin = memberDAO.getMember(memberId);

jminkkk == jimin // false
```

+ 위의 코드에서 동일성을 비교하면 false가 반환
    + jminkkk과 jimin는 같은 데이터베이스 로우에서 조회했지만, **객체 측면에서 둘은 다른 인스턴스**이기 때문

이러한 패러다임의 불일치 문제를 해결하기 위해 DB의 같은 로우를 조회할 때마다 같은 인스턴스를 반환하도록 하는 것은 쉽지 X

## JPA의 등장

JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장
+ 따라서 jminkkk과 jimin는 동일성 비교에 성공

## JPQL
JPA를 사용하면 엔티티 객체를 중심으로 개발하고 데이터베이스에 대한 처리를 JPA에게 위임하게 됨
+ 검색 쿼리에서 JPA는 엔티티를 중심으로 개발하므로 검색을 할 때도 테이블이 아닌, **엔티티 객체를 대상으로 검색**
+ 그런데 엔티티 객체를 대상으로 검색하려면, 데이터베이스의 모든 데이터를 애플리케이션으로 불러와서 엔티티 객체로 변환한 후 검색해야 하는데 사실상 불가능

#### 따라서 JPA는 SQL을 추상화한 JPQL이라는 객체지향 쿼리 언어를 제공
+ SQL문법과 거의 유사하지만 JPQL은 엔티티 객체를 대상으로 쿼리
    + 쉽게 말해 클래스와 필드를 대상으로 쿼리
+ SQL은 데이터베이스 테이블을 대상으로 쿼리

#### 이때 JPQL은 데이터베이스 테이블을 전혀 알지 못한다.

### JPQL 사용
1. em.createQuery 메서드 실행
2. 쿼리 객체를 생성
3. 쿼리 객체의 getResultList() 메서드 호출
4. JPA가 JPQL을 분석하여 적절한 SQL을 만들어 DB에서 조회