# wait와 notify는 올바르게 사용하기가 아주 까다로우니 고수준 유틸리티를 사용하자

- 자바 5에서 도입된 고수준의 동시성 유틸리티가 이 둘로 하드코딩 해야할 일들을 대신 처리해줌

### 실행자 프레임워크

아이템 80 참고

## 동시성 컬렉션

List, Queue, Map과 같은 표준 컬렉션 인터페이스에 동시성을 가미해 구현한 고성능 컬렉션

- 동기화를 각자의 내부에서 수행
    - 동시성 컬렉션에서 동시성을 무력화하는 것은 불가, 외부에서 락을 추가로 사용하면 오히려 속도 저하

### 상태 의존적 수정 메서드

동시성 컬렉션에서 동시성을 무력화하지 못하므로 여러 메서드를 원자적으로 묶어 호출 역시 불가

- 여러 기본 동작을 하나의 원자적 동작으로 묶는 **상태 의존적 수정** 메서드 추가
- Map → putIfAbsent
    - 주어진 키에 매핑된 값이 아직 없을 때만 새 값을 집어 넣음

**동기화된 맵을 동시성 맵으로 교체하는 것만으로** 동시성 애플리케이션의 성능은 극적으로 **개선**됨

## 동기화 장치

스레드가 다른 스레드를 기다릴 수 있게 하여 서로 작업을 조율할 수 있게 함

### wait와 notify 메서드

반복문은 wait 호출 전후로 조건이 만족하는지를 검사하는 역할

- 대기 전에 조건을 검사하여 조건이 충족되었다면 wait를 건너뛰게 한 것은 **응답 불가** 상태를 예방하는 조치
- 만약 조건이 이미 충족되었는데 스레드가 notify 또는 notifyAll 메서드로 먼저 호출한 후 대기 상태로 빠지면, 그 스레드를 다시 깨우지 못할 수 있다.

하지만 조건이 만족되지 않아도 스레드가 깨어날 수 있는 상황이 존재

- notify를 호출하여 대기 중인 스레드가 깨어나는 사이에 다른 스레드가 락을 거는 경우
- 조건이 만족되지 않았지만 실수 혹은 악의적으로 notify를 호출하는 경우
- 대기 중인 스레드 중 일부만 조건을 충족해도 notifyAll로 모든 스레드를 깨우는 경우
- 대기 중인 스레드가 드물게 notify 없이 깨어나는 경우. 허위 각성(spurious wakeup)이라고 한다.