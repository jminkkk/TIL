# 계층형 아키텍처의 문제
### 일반적인 계층형 아키텍쳐

<img src = https://user-images.githubusercontent.com/102847513/223709043-22f79069-01ae-4ee0-9a94-f6c6ff297057.png height = 30% width = 30%>

**일반적인 3계층 아키텍처**

- 웹 계층에서는 요청을 받아 **도메인** 혹은 비지니스 계층에 있는 서비스로 요청을 보냄
- 서비스에서는 필요한 비지니스 로직을 수행하고,
- 도메인 엔티티의 현재 상태를 조회하거나 변경하기 위해 **영속성** 계층의 컴포넌트를 호출

잘 만들어진 계층형 아키텍처는 선택의 폭을 넓히고, 변화하는 요구사항과 외부 요인에 빠르게 적응할 수 있게 해줌

→ 그럼에도 불구하고 계층형 아키텍처의 문제점은 무엇일까?

---

## 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다

웹 → 도메인 → 영속성에 따라 의존하기 때문에 자연스레 DB에 의존하게 되고, 

모든 것이 영속성 계층을 토대로 만들어짐

### 우리가 만드는 어플리케이션의 목적

보통 비지니스를 관장하는 규칙이나 정책을 반영한 모델을 통해 사용자가 이러한 규칙과 정책을 더욱 편리하게 활용할 수 있게 함

이때, 우리는 상태(state)가 아니라 **행동(behavior)을 중심**으로 모델링

- 상태는 중요한 요소이긴 하나 행동이 상태를 바꾸는 주체
    - 고로 행동이 비지니스를 이끌어감

그렇다면 왜 ‘도메인 로직’이 아닌 ‘DB’를 토대로 아키텍처를 만들까?

- ORM 프레임워크 때문일 가능성이 높다
- 도메인 계층에서 데이터베이스 엔티티를 사용하는 것은 영속성 계층과의 강한 결합을 유발함

<img src = https://user-images.githubusercontent.com/102847513/223709116-86f569c9-4246-4d39-a15d-94672e9a4f0d.png height = 40% width = 40%>

- 서비스는 영속성 모델을 비지니스 모델처럼 사용하게 되고
    - 이로 인해 도메인 로직뿐만 아니라 즉시로딩/지연로딩, 데이터베이스 트랜잭션 등 영속성 계층과 관련된 작업을 해야 함

→ 기존의 유연하고 선택의 폭을 넓혀준다던 계층형 아키텍처의 목표와 반대

---

## 지름길을 택하기 쉬워진다

계층형 아키텍처에서 전체적으로 적용되는 유일한 규칙 : 특정한 계층에서는 같은 계층에 있는 컴포넌트나 아래에 있는 계층만 접근 가능한다는 것

- 만약, 상위 계층에 위치한 컴포넌트에 접근해야 한다면 컴포넌트를 계층 아래로 내려버리면 됨
    - 과연 적절한 방법일까?
        
        <img src = https://user-images.githubusercontent.com/102847513/223709346-bc4a0505-4676-47db-b940-5f13ecee8b2b.png height = 40% width = 40%>
        
    
    영속성 계층(최하단 계층)은 수년에 걸친 개발과 유지보수로 위와 같이 될 확률이 큼
    

---

## 테스트하기 어려워진다

계층형 아키텍처를 사용할 때 일반적으로 나타나는 변화의 형태는 계층을 건너뛰는 것

- 엔티티의 필드를 단 하나만 조작하면 되는 경우
    - 웹 계층에서 바로 영속성 계층에 접근하면
    - 도메인 계층을 건드릴 필요 있을까?
        
        <img src = https://user-images.githubusercontent.com/102847513/223709526-2f0e6a5f-7569-4efe-86cc-bcdf3d86600a.png height = 40% width = 40%>
        

### ~~2가지 문제 발생~~

1. 도메인 로직을 웹 계층에 구현하게 됨
    1. 도메인 로직이 어플리케이션 전반에 책임이 섞이고 핵심 도메인 로직들이 퍼짐
2. 웹 계층 테스트에서 도메인 계층뿐만 아니라 영속성 계층도 **Mocking** 해야함
    1. 단위 테스트의 복잡도가 증가하게 됨
        1. 테스트를 전혀 작성하지 않게 됨

---

## 유스케이스를 숨긴다

새 코드를 짜는 것보다 기존의 코드를 바꾸는 것이 더 많은 시간이 걸림

- 그러나 기능을 추가하거나 변경할 적절한 위치를 찾는 일 빈번
- 계층형 아키텍처는 도메인 로직이 여러 계층에 걸쳐 흩어지기 쉽기 때문에 어려워짐

<img src = https://user-images.githubusercontent.com/102847513/223709619-e300483f-8d40-49ba-81ed-b9c3ccc9e424.png height = 40% width = 40%>

### 넓은 서비스

계층형 아키텍처는 도메인 서비스의 ‘너비’에 관한 규칙을 강제하지 않으므로 여러 개의 유스케이스를 담당하는 **아주 넓은 서비스**가 만들어짐

- 넓은 서비스는 영속성 계층에 많은 의존성을 가지게 됨
- 다시 웹 계층의 많은 컴포넌트가 이 서비스에 의존함

---

## 동시 작업이 어려워진다

소프트웨어 개발자는 각기 분리된 파트를 개발할 수 있겠지만 대부분의 경우에는 서로 도움을 주고 받으며 개발함

→ 아키텍처가 동시 작업을 지원해야 하지만 계층형 아키텍처는 X

코드에 넓은 서비스가 있다면 **서로 다른 기능을 동시에 작업**하기는 매우 어려움
