# 완전 탐색
> 블랙잭 문제를 풀다가 아직 낯선 개념인 완전 탐색이라고 겁을 먹고 들어가니 고민을 하게 되었다.
> 
> 완전탐색을 푸는 주요 방법은 1. 재귀 이용, 2. for문 이용 두가지 방법이 있다.

## 완전 탐색이란?
모든 경우의 수를 시도하는 방법으로
+ 상대적으로 구현이 간단하고, 해가 존재하면 항상 찾게 됨
+ 경우의 수에 따라 실행 시간이 비례하기 때문에 입력 값의 범위가 작은 경우 유용

## 완전 탐색 알고리즘
### 단순 Brute-Force
+ 단순히 반복문과 조건문으로 모든 경우를 만들어 답을 구하는 방법
### 비트마스트 (Bitmask)
+ 나올 수 있는 모든 경우의 수가 각각의 원소가 포함되거나, 
+ 포함되지 않는 두 가지 선택으로 구성되는 경우 유용하게 사용
### 재귀함수
+ 비트마스크와 마찬가지로 각 원소가 두 가지 선택지를 가질 때 유용하게 사용
+ 포함이 되면 해당 원소를 넣어 함수를 호출하고, 포함되지 않으면 그 상태에서 함수를 호출하는 등의 식
+ 시간 복잡도 O(N)
### 순열
+ 순열(permutation)은 **서로 다른 N개를 일렬로 나열하는 방법**(경우의 수)를 말함
+ 순열의 경우의 수는 N!으로 완전 탐색을 이용하기 위해서는 N이 한자리 수는 되어야 함
+ 순열에 원소를 하나씩 채워가는 방식.
+ 재귀함수 이용 or C++의 next_permutation() 함수 이용.
+ 시간복잡도 O(N!)
### 너비 우선 탐색(BFS), 깊이 우선 탐색(DFS)
+ 너비우선탐색(Breadth-First Search, BFS)는 하나의 요소를 방문하고 그 요소에 인접한 모든 요소를 우선 방문하는 방식
+ 깊이우선탐색(Depth-First Search, DFS)는 트리의 한 요소(노드)와 다음 수준(level)의 자식 노드를 따라가는 방향으로 탐색하는 방식
+ 길 찾기 등에 주로 쓰이는 알고리즘
    + 단순 길찾기에는 BFS/DFS만 써도 무방하지만,
장애물이 존재하는 등 추가적 연산이 필요할 때 완전탐색 병용하기도 함

## 주의점
+ 완전탐색을 풀 때는 주로 입력의 개수(N)이 작을 때가 좋다. 시간복잡도가 O(2 
N
 ) 혹은 O(N!)이기 때문에 N의 크기가 증가할수록 복잡도는 폭발적으로 증가한다.

+ '답의 범위가 작고, 임의의 답이 조건을 만족하는지 역추적할 수 있을 때' 그리고 '여러 조건 중 하나를 고정시키면 풀이가 간단해질 때' 완전탐색 기법을 사용하길 권장


[참고 블로그](https://velog.io/@hyehyes/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%99%84%EC%A0%84%ED%83%90%EC%83%89)